"""
This type stub file was generated by pyright.
"""

from enum import Enum
from typing import Any, Iterable, Optional, Type

processing_timeout = ...
max_internal_batch_size = ...
class QueueSignals(str, Enum):
    stop = ...
    confirm = ...
    error = ...


class Worker:
    @classmethod
    def start(cls, *args: Any, **kwargs: Any) -> Worker:
        ...
    
    def process(self, items: Iterable[tuple[int, Any]]) -> Iterable[tuple[int, Any]]:
        ...
    


class ParallelWorkerPool:
    def __init__(self, num_workers: int, worker: Type[Worker], start_method: Optional[str] = ..., device_ids: Optional[list[int]] = ..., cuda: bool = ...) -> None:
        ...
    
    def start(self, **kwargs: Any) -> None:
        ...
    
    def ordered_map(self, stream: Iterable[Any], *args: Any, **kwargs: Any) -> Iterable[Any]:
        ...
    
    def semi_ordered_map(self, stream: Iterable[Any], *args: Any, **kwargs: Any) -> Iterable[tuple[int, Any]]:
        ...
    
    def check_worker_health(self) -> None:
        """
        Checks if any worker process has terminated unexpectedly
        """
        ...
    
    def join_or_terminate(self, timeout: Optional[int] = ...) -> None:
        """
        Emergency shutdown
        @param timeout:
        @return:
        """
        ...
    
    def join(self) -> None:
        ...
    
    def __del__(self) -> None:
        """
        Terminate processes if the user hasn't joined. This is necessary as
        leaving stray processes running can corrupt shared state. In brief,
        we've observed shared memory counters being reused (when the memory was
        free from the perspective of the parent process) while the stray
        workers still held a reference to them.
        For a discussion of using destructors in Python in this manner, see
        https://eli.thegreenplace.net/2009/06/12/safely-using-destructors-in-python/.
        """
        ...
    


