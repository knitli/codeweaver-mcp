"""
This type stub file was generated by pyright.
"""

import abc
import contextlib
import datetime
import httpx
import mcp.types
from collections.abc import AsyncIterator, Callable
from pathlib import Path
from typing import Any, Literal, TypeVar, overload
from mcp import ClientSession
from mcp.client.session import ElicitationFnT, ListRootsFnT, LoggingFnT, MessageHandlerFnT, SamplingFnT
from mcp.server.fastmcp import FastMCP as FastMCP1Server
from pydantic import AnyUrl
from typing_extensions import TypedDict, Unpack
from fastmcp.mcp_config import MCPConfig
from fastmcp.server.server import FastMCP

logger = ...
ClientTransportT = TypeVar('ClientTransportT', bound='ClientTransport')
__all__ = ['ClientTransport', 'SSETransport', 'StreamableHttpTransport', 'StdioTransport', 'PythonStdioTransport', 'FastMCPStdioTransport', 'NodeStdioTransport', 'UvxStdioTransport', 'NpxStdioTransport', 'FastMCPTransport', 'infer_transport']
class SessionKwargs(TypedDict, total=False):
    """Keyword arguments for the MCP ClientSession constructor."""
    read_timeout_seconds: datetime.timedelta | None
    sampling_callback: SamplingFnT | None
    list_roots_callback: ListRootsFnT | None
    logging_callback: LoggingFnT | None
    elicitation_callback: ElicitationFnT | None
    message_handler: MessageHandlerFnT | None
    client_info: mcp.types.Implementation | None
    ...


class ClientTransport(abc.ABC):
    """
    Abstract base class for different MCP client transport mechanisms.

    A Transport is responsible for establishing and managing connections
    to an MCP server, and providing a ClientSession within an async context.

    """
    @abc.abstractmethod
    @contextlib.asynccontextmanager
    async def connect_session(self, **session_kwargs: Unpack[SessionKwargs]) -> AsyncIterator[ClientSession]:
        """
        Establishes a connection and yields an active ClientSession.

        The ClientSession is *not* expected to be initialized in this context manager.

        The session is guaranteed to be valid only within the scope of the
        async context manager. Connection setup and teardown are handled
        within this context.

        Args:
            **session_kwargs: Keyword arguments to pass to the ClientSession
                              constructor (e.g., callbacks, timeouts).

        Yields:
            A mcp.ClientSession instance.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    async def close(self): # -> None:
        """Close the transport."""
        ...
    


class WSTransport(ClientTransport):
    """Transport implementation that connects to an MCP server via WebSockets."""
    def __init__(self, url: str | AnyUrl) -> None:
        ...
    
    @contextlib.asynccontextmanager
    async def connect_session(self, **session_kwargs: Unpack[SessionKwargs]) -> AsyncIterator[ClientSession]:
        ...
    
    def __repr__(self) -> str:
        ...
    


class SSETransport(ClientTransport):
    """Transport implementation that connects to an MCP server via Server-Sent Events."""
    def __init__(self, url: str | AnyUrl, headers: dict[str, str] | None = ..., auth: httpx.Auth | Literal['oauth'] | str | None = ..., sse_read_timeout: datetime.timedelta | float | int | None = ..., httpx_client_factory: Callable[[], httpx.AsyncClient] | None = ...) -> None:
        ...
    
    @contextlib.asynccontextmanager
    async def connect_session(self, **session_kwargs: Unpack[SessionKwargs]) -> AsyncIterator[ClientSession]:
        ...
    
    def __repr__(self) -> str:
        ...
    


class StreamableHttpTransport(ClientTransport):
    """Transport implementation that connects to an MCP server via Streamable HTTP Requests."""
    def __init__(self, url: str | AnyUrl, headers: dict[str, str] | None = ..., auth: httpx.Auth | Literal['oauth'] | str | None = ..., sse_read_timeout: datetime.timedelta | float | int | None = ..., httpx_client_factory: Callable[[], httpx.AsyncClient] | None = ...) -> None:
        ...
    
    @contextlib.asynccontextmanager
    async def connect_session(self, **session_kwargs: Unpack[SessionKwargs]) -> AsyncIterator[ClientSession]:
        ...
    
    def __repr__(self) -> str:
        ...
    


class StdioTransport(ClientTransport):
    """
    Base transport for connecting to an MCP server via subprocess with stdio.

    This is a base class that can be subclassed for specific command-based
    transports like Python, Node, Uvx, etc.
    """
    def __init__(self, command: str, args: list[str], env: dict[str, str] | None = ..., cwd: str | None = ..., keep_alive: bool | None = ...) -> None:
        """
        Initialize a Stdio transport.

        Args:
            command: The command to run (e.g., "python", "node", "uvx")
            args: The arguments to pass to the command
            env: Environment variables to set for the subprocess
            cwd: Current working directory for the subprocess
            keep_alive: Whether to keep the subprocess alive between connections.
                       Defaults to True. When True, the subprocess remains active
                       after the connection context exits, allowing reuse in
                       subsequent connections.
        """
        ...
    
    @contextlib.asynccontextmanager
    async def connect_session(self, **session_kwargs: Unpack[SessionKwargs]) -> AsyncIterator[ClientSession]:
        ...
    
    async def connect(self, **session_kwargs: Unpack[SessionKwargs]) -> ClientSession | None:
        ...
    
    async def disconnect(self): # -> None:
        ...
    
    async def close(self): # -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    


class PythonStdioTransport(StdioTransport):
    """Transport for running Python scripts."""
    def __init__(self, script_path: str | Path, args: list[str] | None = ..., env: dict[str, str] | None = ..., cwd: str | None = ..., python_cmd: str = ..., keep_alive: bool | None = ...) -> None:
        """
        Initialize a Python transport.

        Args:
            script_path: Path to the Python script to run
            args: Additional arguments to pass to the script
            env: Environment variables to set for the subprocess
            cwd: Current working directory for the subprocess
            python_cmd: Python command to use (default: "python")
            keep_alive: Whether to keep the subprocess alive between connections.
                       Defaults to True. When True, the subprocess remains active
                       after the connection context exits, allowing reuse in
                       subsequent connections.
        """
        ...
    


class FastMCPStdioTransport(StdioTransport):
    """Transport for running FastMCP servers using the FastMCP CLI."""
    def __init__(self, script_path: str | Path, args: list[str] | None = ..., env: dict[str, str] | None = ..., cwd: str | None = ..., keep_alive: bool | None = ...) -> None:
        ...
    


class NodeStdioTransport(StdioTransport):
    """Transport for running Node.js scripts."""
    def __init__(self, script_path: str | Path, args: list[str] | None = ..., env: dict[str, str] | None = ..., cwd: str | None = ..., node_cmd: str = ..., keep_alive: bool | None = ...) -> None:
        """
        Initialize a Node transport.

        Args:
            script_path: Path to the Node.js script to run
            args: Additional arguments to pass to the script
            env: Environment variables to set for the subprocess
            cwd: Current working directory for the subprocess
            node_cmd: Node.js command to use (default: "node")
            keep_alive: Whether to keep the subprocess alive between connections.
                       Defaults to True. When True, the subprocess remains active
                       after the connection context exits, allowing reuse in
                       subsequent connections.
        """
        ...
    


class UvxStdioTransport(StdioTransport):
    """Transport for running commands via the uvx tool."""
    def __init__(self, tool_name: str, tool_args: list[str] | None = ..., project_directory: str | None = ..., python_version: str | None = ..., with_packages: list[str] | None = ..., from_package: str | None = ..., env_vars: dict[str, str] | None = ..., keep_alive: bool | None = ...) -> None:
        """
        Initialize a Uvx transport.

        Args:
            tool_name: Name of the tool to run via uvx
            tool_args: Arguments to pass to the tool
            project_directory: Project directory (for package resolution)
            python_version: Python version to use
            with_packages: Additional packages to include
            from_package: Package to install the tool from
            env_vars: Additional environment variables
            keep_alive: Whether to keep the subprocess alive between connections.
                       Defaults to True. When True, the subprocess remains active
                       after the connection context exits, allowing reuse in
                       subsequent connections.
        """
        ...
    


class NpxStdioTransport(StdioTransport):
    """Transport for running commands via the npx tool."""
    def __init__(self, package: str, args: list[str] | None = ..., project_directory: str | None = ..., env_vars: dict[str, str] | None = ..., use_package_lock: bool = ..., keep_alive: bool | None = ...) -> None:
        """
        Initialize an Npx transport.

        Args:
            package: Name of the npm package to run
            args: Arguments to pass to the package command
            project_directory: Project directory with package.json
            env_vars: Additional environment variables
            use_package_lock: Whether to use package-lock.json (--prefer-offline)
            keep_alive: Whether to keep the subprocess alive between connections.
                       Defaults to True. When True, the subprocess remains active
                       after the connection context exits, allowing reuse in
                       subsequent connections.
        """
        ...
    


class FastMCPTransport(ClientTransport):
    """In-memory transport for FastMCP servers.

    This transport connects directly to a FastMCP server instance in the same
    Python process. It works with both FastMCP 2.x servers and FastMCP 1.0
    servers from the low-level MCP SDK. This is particularly useful for unit
    tests or scenarios where client and server run in the same runtime.
    """
    def __init__(self, mcp: FastMCP | FastMCP1Server, raise_exceptions: bool = ...) -> None:
        """Initialize a FastMCPTransport from a FastMCP server instance."""
        ...
    
    @contextlib.asynccontextmanager
    async def connect_session(self, **session_kwargs: Unpack[SessionKwargs]) -> AsyncIterator[ClientSession]:
        ...
    
    def __repr__(self) -> str:
        ...
    


class MCPConfigTransport(ClientTransport):
    """Transport for connecting to one or more MCP servers defined in an MCPConfig.

    This transport provides a unified interface to multiple MCP servers defined in an MCPConfig
    object or dictionary matching the MCPConfig schema. It supports two key scenarios:

    1. If the MCPConfig contains exactly one server, it creates a direct transport to that server.
    2. If the MCPConfig contains multiple servers, it creates a composite client by mounting
       all servers on a single FastMCP instance, with each server's name used as its mounting prefix.

    In the multi-server case, tools are accessible with the prefix pattern `{server_name}_{tool_name}`
    and resources with the pattern `protocol://{server_name}/path/to/resource`.

    This is particularly useful for creating clients that need to interact with multiple specialized
    MCP servers through a single interface, simplifying client code.

    Examples:
        ```python
        from fastmcp import Client
        from fastmcp.utilities.mcp_config import MCPConfig

        # Create a config with multiple servers
        config = {
            "mcpServers": {
                "weather": {
                    "url": "https://weather-api.example.com/mcp",
                    "transport": "http"
                },
                "calendar": {
                    "url": "https://calendar-api.example.com/mcp",
                    "transport": "http"
                }
            }
        }

        # Create a client with the config
        client = Client(config)

        async with client:
            # Access tools with prefixes
            weather = await client.call_tool("weather_get_forecast", {"city": "London"})
            events = await client.call_tool("calendar_list_events", {"date": "2023-06-01"})

            # Access resources with prefixed URIs
            icons = await client.read_resource("weather://weather/icons/sunny")
        ```
    """
    def __init__(self, config: MCPConfig | dict) -> None:
        ...
    
    @contextlib.asynccontextmanager
    async def connect_session(self, **session_kwargs: Unpack[SessionKwargs]) -> AsyncIterator[ClientSession]:
        ...
    
    def __repr__(self) -> str:
        ...
    


@overload
def infer_transport(transport: ClientTransportT) -> ClientTransportT:
    ...

@overload
def infer_transport(transport: FastMCP) -> FastMCPTransport:
    ...

@overload
def infer_transport(transport: FastMCP1Server) -> FastMCPTransport:
    ...

@overload
def infer_transport(transport: MCPConfig) -> MCPConfigTransport:
    ...

@overload
def infer_transport(transport: dict[str, Any]) -> MCPConfigTransport:
    ...

@overload
def infer_transport(transport: AnyUrl) -> SSETransport | StreamableHttpTransport:
    ...

@overload
def infer_transport(transport: str) -> PythonStdioTransport | NodeStdioTransport | SSETransport | StreamableHttpTransport:
    ...

@overload
def infer_transport(transport: Path) -> PythonStdioTransport | NodeStdioTransport:
    ...

def infer_transport(transport: ClientTransport | FastMCP | FastMCP1Server | AnyUrl | Path | MCPConfig | dict[str, Any] | str) -> ClientTransport:
    """
    Infer the appropriate transport type from the given transport argument.

    This function attempts to infer the correct transport type from the provided
    argument, handling various input types and converting them to the appropriate
    ClientTransport subclass.

    The function supports these input types:
    - ClientTransport: Used directly without modification
    - FastMCP or FastMCP1Server: Creates an in-memory FastMCPTransport
    - Path or str (file path): Creates PythonStdioTransport (.py) or NodeStdioTransport (.js)
    - AnyUrl or str (URL): Creates StreamableHttpTransport (default) or SSETransport (for /sse endpoints)
    - MCPConfig or dict: Creates MCPConfigTransport, potentially connecting to multiple servers

    For HTTP URLs, they are assumed to be Streamable HTTP URLs unless they end in `/sse`.

    For MCPConfig with multiple servers, a composite client is created where each server
    is mounted with its name as prefix. This allows accessing tools and resources from multiple
    servers through a single unified client interface, using naming patterns like
    `servername_toolname` for tools and `protocol://servername/path` for resources.
    If the MCPConfig contains only one server, a direct connection is established without prefixing.

    Examples:
        ```python
        # Connect to a local Python script
        transport = infer_transport("my_script.py")

        # Connect to a remote server via HTTP
        transport = infer_transport("http://example.com/mcp")

        # Connect to multiple servers using MCPConfig
        config = {
            "mcpServers": {
                "weather": {"url": "http://weather.example.com/mcp"},
                "calendar": {"url": "http://calendar.example.com/mcp"}
            }
        }
        transport = infer_transport(config)
        ```
    """
    ...

