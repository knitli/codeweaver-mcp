"""
This type stub file was generated by pyright.
"""

import mcp.types
from collections.abc import Callable
from functools import lru_cache
from pathlib import Path
from types import EllipsisType
from typing import TypeAlias, TypeVar
from mcp.types import Annotations
from pydantic import BaseModel, TypeAdapter

"""Common types used across FastMCP."""
T = TypeVar('T')
NotSet = ...
NotSetT: TypeAlias = EllipsisType
class FastMCPBaseModel(BaseModel):
    """Base model for FastMCP models."""
    model_config = ...


@lru_cache(maxsize=5000)
def get_cached_typeadapter(cls: T) -> TypeAdapter[T]:
    """
    TypeAdapters are heavy objects, and in an application context we'd typically
    create them once in a global scope and reuse them as often as possible.
    However, this isn't feasible for user-generated functions. Instead, we use a
    cache to minimize the cost of creating them as much as possible.
    """
    ...

def issubclass_safe(cls: type, base: type) -> bool:
    """Check if cls is a subclass of base, even if cls is a type variable."""
    ...

def is_class_member_of_type(cls: type, base: type) -> bool:
    """
    Check if cls is a member of base, even if cls is a type variable.

    Base can be a type, a UnionType, or an Annotated type. Generic types are not
    considered members (e.g. T is not a member of list[T]).
    """
    ...

def find_kwarg_by_type(fn: Callable, kwarg_type: type) -> str | None:
    """
    Find the name of the kwarg that is of type kwarg_type.

    Includes union types that contain the kwarg_type, as well as Annotated types.
    """
    ...

class Image:
    """Helper class for returning images from tools."""
    def __init__(self, path: str | Path | None = ..., data: bytes | None = ..., format: str | None = ..., annotations: Annotations | None = ...) -> None:
        ...
    
    def to_image_content(self, mime_type: str | None = ..., annotations: Annotations | None = ...) -> mcp.types.ImageContent:
        """Convert to MCP ImageContent."""
        ...
    


class Audio:
    """Helper class for returning audio from tools."""
    def __init__(self, path: str | Path | None = ..., data: bytes | None = ..., format: str | None = ..., annotations: Annotations | None = ...) -> None:
        ...
    
    def to_audio_content(self, mime_type: str | None = ..., annotations: Annotations | None = ...) -> mcp.types.AudioContent:
        ...
    


class File:
    """Helper class for returning audio from tools."""
    def __init__(self, path: str | Path | None = ..., data: bytes | None = ..., format: str | None = ..., name: str | None = ..., annotations: Annotations | None = ...) -> None:
        ...
    
    def to_resource_content(self, mime_type: str | None = ..., annotations: Annotations | None = ...) -> mcp.types.EmbeddedResource:
        ...
    


def replace_type(type_, type_map: dict[type, type]): # -> type | UnionType | Any:
    """
    Given a (possibly generic, nested, or otherwise complex) type, replaces all
    instances of old_type with new_type.

    This is useful for transforming types when creating tools.

    Args:
        type_: The type to replace instances of old_type with new_type.
        old_type: The type to replace.
        new_type: The type to replace old_type with.

    Examples:
        >>> replace_type(list[int | bool], {int: str})
        list[str | bool]

        >>> replace_type(list[list[int]], {int: str})
        list[list[str]]

    """
    ...

