"""
This type stub file was generated by pyright.
"""

import httpx
from collections.abc import AsyncIterator, Callable
from contextlib import AbstractAsyncContextManager, asynccontextmanager
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Generic, Literal, TYPE_CHECKING, overload
from mcp.server.lowlevel.server import LifespanResultT
from mcp.types import AnyFunction, ToolAnnotations
from pydantic import AnyUrl
from starlette.middleware import Middleware as ASGIMiddleware
from fastmcp.mcp_config import MCPConfig
from fastmcp.prompts import Prompt
from fastmcp.prompts.prompt import FunctionPrompt
from fastmcp.resources import Resource
from fastmcp.resources.template import ResourceTemplate
from fastmcp.server.auth.auth import OAuthProvider
from fastmcp.server.http import StarletteWithLifespan
from fastmcp.server.middleware import Middleware
from fastmcp.settings import Settings
from fastmcp.tools.tool import FunctionTool, Tool
from fastmcp.utilities.types import NotSetT
from fastmcp.client import Client
from fastmcp.client.transports import ClientTransport, ClientTransportT
from fastmcp.server.openapi import ComponentFn as OpenAPIComponentFn, FastMCPOpenAPI, RouteMap, RouteMapFn as OpenAPIRouteMapFn
from fastmcp.server.proxy import FastMCPProxy

"""FastMCP - A more ergonomic interface for MCP servers."""
if TYPE_CHECKING:
    ...
logger = ...
DuplicateBehavior = Literal['warn', 'error', 'replace', 'ignore']
Transport = Literal['stdio', 'http', 'sse', 'streamable-http']
URI_PATTERN = ...
@asynccontextmanager
async def default_lifespan(server: FastMCP[LifespanResultT]) -> AsyncIterator[Any]:
    """Default lifespan context manager that does nothing.

    Args:
        server: The server instance this lifespan is managing

    Returns:
        An empty context object
    """
    ...

class FastMCP(Generic[LifespanResultT]):
    def __init__(self, name: str | None = ..., instructions: str | None = ..., *, version: str | None = ..., auth: OAuthProvider | None = ..., middleware: list[Middleware] | None = ..., lifespan: Callable[[FastMCP[LifespanResultT]], AbstractAsyncContextManager[LifespanResultT]] | None = ..., tool_serializer: Callable[[Any], str] | None = ..., cache_expiration_seconds: float | None = ..., on_duplicate_tools: DuplicateBehavior | None = ..., on_duplicate_resources: DuplicateBehavior | None = ..., on_duplicate_prompts: DuplicateBehavior | None = ..., resource_prefix_format: Literal['protocol', 'path'] | None = ..., mask_error_details: bool | None = ..., tools: list[Tool | Callable[..., Any]] | None = ..., dependencies: list[str] | None = ..., include_tags: set[str] | None = ..., exclude_tags: set[str] | None = ..., log_level: str | None = ..., debug: bool | None = ..., host: str | None = ..., port: int | None = ..., sse_path: str | None = ..., message_path: str | None = ..., streamable_http_path: str | None = ..., json_response: bool | None = ..., stateless_http: bool | None = ...) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def settings(self) -> Settings:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def instructions(self) -> str | None:
        ...
    
    async def run_async(self, transport: Transport | None = ..., show_banner: bool = ..., **transport_kwargs: Any) -> None:
        """Run the FastMCP server asynchronously.

        Args:
            transport: Transport protocol to use ("stdio", "sse", or "streamable-http")
        """
        ...
    
    def run(self, transport: Transport | None = ..., show_banner: bool = ..., **transport_kwargs: Any) -> None:
        """Run the FastMCP server. Note this is a synchronous function.

        Args:
            transport: Transport protocol to use ("stdio", "sse", or "streamable-http")
        """
        ...
    
    def add_middleware(self, middleware: Middleware) -> None:
        ...
    
    async def get_tools(self) -> dict[str, Tool]:
        """Get all registered tools, indexed by registered key."""
        ...
    
    async def get_tool(self, key: str) -> Tool:
        ...
    
    async def get_resources(self) -> dict[str, Resource]:
        """Get all registered resources, indexed by registered key."""
        ...
    
    async def get_resource(self, key: str) -> Resource:
        ...
    
    async def get_resource_templates(self) -> dict[str, ResourceTemplate]:
        """Get all registered resource templates, indexed by registered key."""
        ...
    
    async def get_resource_template(self, key: str) -> ResourceTemplate:
        """Get a registered resource template by key."""
        ...
    
    async def get_prompts(self) -> dict[str, Prompt]:
        """
        List all available prompts.
        """
        ...
    
    async def get_prompt(self, key: str) -> Prompt:
        ...
    
    def custom_route(self, path: str, methods: list[str], name: str | None = ..., include_in_schema: bool = ...): # -> Callable[..., Callable[[Request], Awaitable[Response]]]:
        """
        Decorator to register a custom HTTP route on the FastMCP server.

        Allows adding arbitrary HTTP endpoints outside the standard MCP protocol,
        which can be useful for OAuth callbacks, health checks, or admin APIs.
        The handler function must be an async function that accepts a Starlette
        Request and returns a Response.

        Args:
            path: URL path for the route (e.g., "/oauth/callback")
            methods: List of HTTP methods to support (e.g., ["GET", "POST"])
            name: Optional name for the route (to reference this route with
                Starlette's reverse URL lookup feature)
            include_in_schema: Whether to include in OpenAPI schema, defaults to True

        Example:
            Register a custom HTTP route for a health check endpoint:
            ```python
            @server.custom_route("/health", methods=["GET"])
            async def health_check(request: Request) -> Response:
                return JSONResponse({"status": "ok"})
            ```
        """
        ...
    
    def add_tool(self, tool: Tool) -> Tool:
        """Add a tool to the server.

        The tool function can optionally request a Context object by adding a parameter
        with the Context type annotation. See the @tool decorator for examples.

        Args:
            tool: The Tool instance to register

        Returns:
            The tool instance that was added to the server.
        """
        ...
    
    def remove_tool(self, name: str) -> None:
        """Remove a tool from the server.

        Args:
            name: The name of the tool to remove

        Raises:
            NotFoundError: If the tool is not found
        """
        ...
    
    @overload
    def tool(self, name_or_fn: AnyFunction, *, name: str | None = ..., title: str | None = ..., description: str | None = ..., tags: set[str] | None = ..., output_schema: dict[str, Any] | None | NotSetT = ..., annotations: ToolAnnotations | dict[str, Any] | None = ..., exclude_args: list[str] | None = ..., enabled: bool | None = ...) -> FunctionTool:
        ...
    
    @overload
    def tool(self, name_or_fn: str | None = ..., *, name: str | None = ..., title: str | None = ..., description: str | None = ..., tags: set[str] | None = ..., output_schema: dict[str, Any] | None | NotSetT = ..., annotations: ToolAnnotations | dict[str, Any] | None = ..., exclude_args: list[str] | None = ..., enabled: bool | None = ...) -> Callable[[AnyFunction], FunctionTool]:
        ...
    
    def tool(self, name_or_fn: str | AnyFunction | None = ..., *, name: str | None = ..., title: str | None = ..., description: str | None = ..., tags: set[str] | None = ..., output_schema: dict[str, Any] | None | NotSetT = ..., annotations: ToolAnnotations | dict[str, Any] | None = ..., exclude_args: list[str] | None = ..., enabled: bool | None = ...) -> Callable[[AnyFunction], FunctionTool] | FunctionTool:
        """Decorator to register a tool.

        Tools can optionally request a Context object by adding a parameter with the
        Context type annotation. The context provides access to MCP capabilities like
        logging, progress reporting, and resource access.

        This decorator supports multiple calling patterns:
        - @server.tool (without parentheses)
        - @server.tool (with empty parentheses)
        - @server.tool("custom_name") (with name as first argument)
        - @server.tool(name="custom_name") (with name as keyword argument)
        - server.tool(function, name="custom_name") (direct function call)

        Args:
            name_or_fn: Either a function (when used as @tool), a string name, or None
            name: Optional name for the tool (keyword-only, alternative to name_or_fn)
            description: Optional description of what the tool does
            tags: Optional set of tags for categorizing the tool
            output_schema: Optional JSON schema for the tool's output
            annotations: Optional annotations about the tool's behavior
            exclude_args: Optional list of argument names to exclude from the tool schema
            enabled: Optional boolean to enable or disable the tool

        Examples:
            Register a tool with a custom name:
            ```python
            @server.tool
            def my_tool(x: int) -> str:
                return str(x)

            # Register a tool with a custom name
            @server.tool
            def my_tool(x: int) -> str:
                return str(x)

            @server.tool("custom_name")
            def my_tool(x: int) -> str:
                return str(x)

            @server.tool(name="custom_name")
            def my_tool(x: int) -> str:
                return str(x)

            # Direct function call
            server.tool(my_function, name="custom_name")
            ```
        """
        ...
    
    def add_resource(self, resource: Resource) -> Resource:
        """Add a resource to the server.

        Args:
            resource: A Resource instance to add

        Returns:
            The resource instance that was added to the server.
        """
        ...
    
    def add_template(self, template: ResourceTemplate) -> ResourceTemplate:
        """Add a resource template to the server.

        Args:
            template: A ResourceTemplate instance to add

        Returns:
            The template instance that was added to the server.
        """
        ...
    
    def add_resource_fn(self, fn: AnyFunction, uri: str, name: str | None = ..., description: str | None = ..., mime_type: str | None = ..., tags: set[str] | None = ...) -> None:
        """Add a resource or template to the server from a function.

        If the URI contains parameters (e.g. "resource://{param}") or the function
        has parameters, it will be registered as a template resource.

        Args:
            fn: The function to register as a resource
            uri: The URI for the resource
            name: Optional name for the resource
            description: Optional description of the resource
            mime_type: Optional MIME type for the resource
            tags: Optional set of tags for categorizing the resource
        """
        ...
    
    def resource(self, uri: str, *, name: str | None = ..., title: str | None = ..., description: str | None = ..., mime_type: str | None = ..., tags: set[str] | None = ..., enabled: bool | None = ...) -> Callable[[AnyFunction], Resource | ResourceTemplate]:
        """Decorator to register a function as a resource.

        The function will be called when the resource is read to generate its content.
        The function can return:
        - str for text content
        - bytes for binary content
        - other types will be converted to JSON

        Resources can optionally request a Context object by adding a parameter with the
        Context type annotation. The context provides access to MCP capabilities like
        logging, progress reporting, and session information.

        If the URI contains parameters (e.g. "resource://{param}") or the function
        has parameters, it will be registered as a template resource.

        Args:
            uri: URI for the resource (e.g. "resource://my-resource" or "resource://{param}")
            name: Optional name for the resource
            description: Optional description of the resource
            mime_type: Optional MIME type for the resource
            tags: Optional set of tags for categorizing the resource
            enabled: Optional boolean to enable or disable the resource

        Examples:
            Register a resource with a custom name:
            ```python
            @server.resource("resource://my-resource")
            def get_data() -> str:
                return "Hello, world!"

            @server.resource("resource://my-resource")
            async get_data() -> str:
                data = await fetch_data()
                return f"Hello, world! {data}"

            @server.resource("resource://{city}/weather")
            def get_weather(city: str) -> str:
                return f"Weather for {city}"

            @server.resource("resource://{city}/weather")
            def get_weather_with_context(city: str, ctx: Context) -> str:
                ctx.info(f"Fetching weather for {city}")
                return f"Weather for {city}"

            @server.resource("resource://{city}/weather")
            async def get_weather(city: str) -> str:
                data = await fetch_weather(city)
                return f"Weather for {city}: {data}"
            ```
        """
        ...
    
    def add_prompt(self, prompt: Prompt) -> Prompt:
        """Add a prompt to the server.

        Args:
            prompt: A Prompt instance to add

        Returns:
            The prompt instance that was added to the server.
        """
        ...
    
    @overload
    def prompt(self, name_or_fn: AnyFunction, *, name: str | None = ..., title: str | None = ..., description: str | None = ..., tags: set[str] | None = ..., enabled: bool | None = ...) -> FunctionPrompt:
        ...
    
    @overload
    def prompt(self, name_or_fn: str | None = ..., *, name: str | None = ..., title: str | None = ..., description: str | None = ..., tags: set[str] | None = ..., enabled: bool | None = ...) -> Callable[[AnyFunction], FunctionPrompt]:
        ...
    
    def prompt(self, name_or_fn: str | AnyFunction | None = ..., *, name: str | None = ..., title: str | None = ..., description: str | None = ..., tags: set[str] | None = ..., enabled: bool | None = ...) -> Callable[[AnyFunction], FunctionPrompt] | FunctionPrompt:
        """Decorator to register a prompt.

        Prompts can optionally request a Context object by adding a parameter with the
        Context type annotation. The context provides access to MCP capabilities like
        logging, progress reporting, and session information.

        This decorator supports multiple calling patterns:
        - @server.prompt (without parentheses)
        - @server.prompt() (with empty parentheses)
        - @server.prompt("custom_name") (with name as first argument)
        - @server.prompt(name="custom_name") (with name as keyword argument)
        - server.prompt(function, name="custom_name") (direct function call)

        Args:
            name_or_fn: Either a function (when used as @prompt), a string name, or None
            name: Optional name for the prompt (keyword-only, alternative to name_or_fn)
            description: Optional description of what the prompt does
            tags: Optional set of tags for categorizing the prompt
            enabled: Optional boolean to enable or disable the prompt

        Examples:

            ```python
            @server.prompt
            def analyze_table(table_name: str) -> list[Message]:
                schema = read_table_schema(table_name)
                return [
                    {
                        "role": "user",
                        "content": f"Analyze this schema:
{schema}"
                    }
                ]

            @server.prompt()
            def analyze_with_context(table_name: str, ctx: Context) -> list[Message]:
                ctx.info(f"Analyzing table {table_name}")
                schema = read_table_schema(table_name)
                return [
                    {
                        "role": "user",
                        "content": f"Analyze this schema:
{schema}"
                    }
                ]

            @server.prompt("custom_name")
            def analyze_file(path: str) -> list[Message]:
                content = await read_file(path)
                return [
                    {
                        "role": "user",
                        "content": {
                            "type": "resource",
                            "resource": {
                                "uri": f"file://{path}",
                                "text": content
                            }
                        }
                    }
                ]

            @server.prompt(name="custom_name")
            def another_prompt(data: str) -> list[Message]:
                return [{"role": "user", "content": data}]

            # Direct function call
            server.prompt(my_function, name="custom_name")
            ```
        """
        ...
    
    async def run_stdio_async(self, show_banner: bool = ...) -> None:
        """Run the server using stdio transport."""
        ...
    
    async def run_http_async(self, show_banner: bool = ..., transport: Literal['http', 'streamable-http', 'sse'] = ..., host: str | None = ..., port: int | None = ..., log_level: str | None = ..., path: str | None = ..., uvicorn_config: dict[str, Any] | None = ..., middleware: list[ASGIMiddleware] | None = ..., stateless_http: bool | None = ...) -> None:
        """Run the server using HTTP transport.

        Args:
            transport: Transport protocol to use - either "streamable-http" (default) or "sse"
            host: Host address to bind to (defaults to settings.host)
            port: Port to bind to (defaults to settings.port)
            log_level: Log level for the server (defaults to settings.log_level)
            path: Path for the endpoint (defaults to settings.streamable_http_path or settings.sse_path)
            uvicorn_config: Additional configuration for the Uvicorn server
            middleware: A list of middleware to apply to the app
            stateless_http: Whether to use stateless HTTP (defaults to settings.stateless_http)
        """
        ...
    
    async def run_sse_async(self, host: str | None = ..., port: int | None = ..., log_level: str | None = ..., path: str | None = ..., uvicorn_config: dict[str, Any] | None = ...) -> None:
        """Run the server using SSE transport."""
        ...
    
    def sse_app(self, path: str | None = ..., message_path: str | None = ..., middleware: list[ASGIMiddleware] | None = ...) -> StarletteWithLifespan:
        """
        Create a Starlette app for the SSE server.

        Args:
            path: The path to the SSE endpoint
            message_path: The path to the message endpoint
            middleware: A list of middleware to apply to the app
        """
        ...
    
    def streamable_http_app(self, path: str | None = ..., middleware: list[ASGIMiddleware] | None = ...) -> StarletteWithLifespan:
        """
        Create a Starlette app for the StreamableHTTP server.

        Args:
            path: The path to the StreamableHTTP endpoint
            middleware: A list of middleware to apply to the app
        """
        ...
    
    def http_app(self, path: str | None = ..., middleware: list[ASGIMiddleware] | None = ..., json_response: bool | None = ..., stateless_http: bool | None = ..., transport: Literal['http', 'streamable-http', 'sse'] = ...) -> StarletteWithLifespan:
        """Create a Starlette app using the specified HTTP transport.

        Args:
            path: The path for the HTTP endpoint
            middleware: A list of middleware to apply to the app
            transport: Transport protocol to use - either "streamable-http" (default) or "sse"

        Returns:
            A Starlette application configured with the specified transport
        """
        ...
    
    async def run_streamable_http_async(self, host: str | None = ..., port: int | None = ..., log_level: str | None = ..., path: str | None = ..., uvicorn_config: dict[str, Any] | None = ...) -> None:
        ...
    
    def mount(self, server: FastMCP[LifespanResultT], prefix: str | None = ..., as_proxy: bool | None = ..., *, tool_separator: str | None = ..., resource_separator: str | None = ..., prompt_separator: str | None = ...) -> None:
        """Mount another FastMCP server on this server with an optional prefix.

        Unlike importing (with import_server), mounting establishes a dynamic connection
        between servers. When a client interacts with a mounted server's objects through
        the parent server, requests are forwarded to the mounted server in real-time.
        This means changes to the mounted server are immediately reflected when accessed
        through the parent.

        When a server is mounted with a prefix:
        - Tools from the mounted server are accessible with prefixed names.
          Example: If server has a tool named "get_weather", it will be available as "prefix_get_weather".
        - Resources are accessible with prefixed URIs.
          Example: If server has a resource with URI "weather://forecast", it will be available as
          "weather://prefix/forecast".
        - Templates are accessible with prefixed URI templates.
          Example: If server has a template with URI "weather://location/{id}", it will be available
          as "weather://prefix/location/{id}".
        - Prompts are accessible with prefixed names.
          Example: If server has a prompt named "weather_prompt", it will be available as
          "prefix_weather_prompt".

        When a server is mounted without a prefix (prefix=None), its tools, resources, templates,
        and prompts are accessible with their original names. Multiple servers can be mounted
        without prefixes, and they will be tried in order until a match is found.

        There are two modes for mounting servers:
        1. Direct mounting (default when server has no custom lifespan): The parent server
           directly accesses the mounted server's objects in-memory for better performance.
           In this mode, no client lifecycle events occur on the mounted server, including
           lifespan execution.

        2. Proxy mounting (default when server has a custom lifespan): The parent server
           treats the mounted server as a separate entity and communicates with it via a
           Client transport. This preserves all client-facing behaviors, including lifespan
           execution, but with slightly higher overhead.

        Args:
            server: The FastMCP server to mount.
            prefix: Optional prefix to use for the mounted server's objects. If None,
                the server's objects are accessible with their original names.
            as_proxy: Whether to treat the mounted server as a proxy. If None (default),
                automatically determined based on whether the server has a custom lifespan
                (True if it has a custom lifespan, False otherwise).
            tool_separator: Deprecated. Separator character for tool names.
            resource_separator: Deprecated. Separator character for resource URIs.
            prompt_separator: Deprecated. Separator character for prompt names.
        """
        ...
    
    async def import_server(self, server: FastMCP[LifespanResultT], prefix: str | None = ..., tool_separator: str | None = ..., resource_separator: str | None = ..., prompt_separator: str | None = ...) -> None:
        """
        Import the MCP objects from another FastMCP server into this one,
        optionally with a given prefix.

        Note that when a server is *imported*, its objects are immediately
        registered to the importing server. This is a one-time operation and
        future changes to the imported server will not be reflected in the
        importing server. Server-level configurations and lifespans are not imported.

        When a server is imported with a prefix:
        - The tools are imported with prefixed names
          Example: If server has a tool named "get_weather", it will be
          available as "prefix_get_weather"
        - The resources are imported with prefixed URIs using the new format
          Example: If server has a resource with URI "weather://forecast", it will
          be available as "weather://prefix/forecast"
        - The templates are imported with prefixed URI templates using the new format
          Example: If server has a template with URI "weather://location/{id}", it will
          be available as "weather://prefix/location/{id}"
        - The prompts are imported with prefixed names
          Example: If server has a prompt named "weather_prompt", it will be available as
          "prefix_weather_prompt"

        When a server is imported without a prefix (prefix=None), its tools, resources,
        templates, and prompts are imported with their original names.

        Args:
            server: The FastMCP server to import
            prefix: Optional prefix to use for the imported server's objects. If None,
                objects are imported with their original names.
            tool_separator: Deprecated. Separator for tool names.
            resource_separator: Deprecated and ignored. Prefix is now
              applied using the protocol://prefix/path format
            prompt_separator: Deprecated. Separator for prompt names.
        """
        ...
    
    @classmethod
    def from_openapi(cls, openapi_spec: dict[str, Any], client: httpx.AsyncClient, route_maps: list[RouteMap] | None = ..., route_map_fn: OpenAPIRouteMapFn | None = ..., mcp_component_fn: OpenAPIComponentFn | None = ..., mcp_names: dict[str, str] | None = ..., tags: set[str] | None = ..., **settings: Any) -> FastMCPOpenAPI:
        """
        Create a FastMCP server from an OpenAPI specification.
        """
        ...
    
    @classmethod
    def from_fastapi(cls, app: Any, name: str | None = ..., route_maps: list[RouteMap] | None = ..., route_map_fn: OpenAPIRouteMapFn | None = ..., mcp_component_fn: OpenAPIComponentFn | None = ..., mcp_names: dict[str, str] | None = ..., httpx_client_kwargs: dict[str, Any] | None = ..., tags: set[str] | None = ..., **settings: Any) -> FastMCPOpenAPI:
        """
        Create a FastMCP server from a FastAPI application.
        """
        ...
    
    @classmethod
    def as_proxy(cls, backend: Client[ClientTransportT] | ClientTransport | FastMCP[Any] | AnyUrl | Path | MCPConfig | dict[str, Any] | str, **settings: Any) -> FastMCPProxy:
        """Create a FastMCP proxy server for the given backend.

        The `backend` argument can be either an existing `fastmcp.client.Client`
        instance or any value accepted as the `transport` argument of
        `fastmcp.client.Client`. This mirrors the convenience of the
        `fastmcp.client.Client` constructor.
        """
        ...
    
    @classmethod
    def from_client(cls, client: Client[ClientTransportT], **settings: Any) -> FastMCPProxy:
        """
        Create a FastMCP proxy server from a FastMCP client.
        """
        ...
    


@dataclass
class MountedServer:
    prefix: str | None
    server: FastMCP[Any]
    resource_prefix_format: Literal['protocol', 'path'] | None = ...


def add_resource_prefix(uri: str, prefix: str, prefix_format: Literal['protocol', 'path'] | None = ...) -> str:
    """Add a prefix to a resource URI.

    Args:
        uri: The original resource URI
        prefix: The prefix to add

    Returns:
        The resource URI with the prefix added

    Examples:
        With new style:
        ```python
        add_resource_prefix("resource://path/to/resource", "prefix")
        "resource://prefix/path/to/resource"
        ```
        With legacy style:
        ```python
        add_resource_prefix("resource://path/to/resource", "prefix")
        "prefix+resource://path/to/resource"
        ```
        With absolute path:
        ```python
        add_resource_prefix("resource:///absolute/path", "prefix")
        "resource://prefix//absolute/path"
        ```

    Raises:
        ValueError: If the URI doesn't match the expected protocol://path format
    """
    ...

def remove_resource_prefix(uri: str, prefix: str, prefix_format: Literal['protocol', 'path'] | None = ...) -> str:
    """Remove a prefix from a resource URI.

    Args:
        uri: The resource URI with a prefix
        prefix: The prefix to remove
        prefix_format: The format of the prefix to remove
    Returns:
        The resource URI with the prefix removed

    Examples:
        With new style:
        ```python
        remove_resource_prefix("resource://prefix/path/to/resource", "prefix")
        "resource://path/to/resource"
        ```
        With legacy style:
        ```python
        remove_resource_prefix("prefix+resource://path/to/resource", "prefix")
        "resource://path/to/resource"
        ```
        With absolute path:
        ```python
        remove_resource_prefix("resource://prefix//absolute/path", "prefix")
        "resource:///absolute/path"
        ```

    Raises:
        ValueError: If the URI doesn't match the expected protocol://path format
    """
    ...

def has_resource_prefix(uri: str, prefix: str, prefix_format: Literal['protocol', 'path'] | None = ...) -> bool:
    """Check if a resource URI has a specific prefix.

    Args:
        uri: The resource URI to check
        prefix: The prefix to look for

    Returns:
        True if the URI has the specified prefix, False otherwise

    Examples:
        With new style:
        ```python
        has_resource_prefix("resource://prefix/path/to/resource", "prefix")
        True
        ```
        With legacy style:
        ```python
        has_resource_prefix("prefix+resource://path/to/resource", "prefix")
        True
        ```
        With other path:
        ```python
        has_resource_prefix("resource://other/path/to/resource", "prefix")
        False
        ```

    Raises:
        ValueError: If the URI doesn't match the expected protocol://path format
    """
    ...

